Activity 1:

No questions

Activity 2:

1. A deck has a composition made of cards. The deck object contains all the cards object.

2. Six cards.

3. rank = [Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King]
   pointValue = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10] or pointValue = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   suit = [Heart, Spade, Club, Diamond]


4. The order in the arrays for card rank and point values matter, while the order for the suits do not matter. Since the point value for the card is the same, or nearly the same, as the card rank, these values must have the same index for the card to have the correct value. The suit order does not matter, as the all values and name for the card will be assigned to the suit.

Activity 3:

1. 
	public static void flip()
	{
		int random = (int) ((Math.random() * 4) + 1)
		if(random != 2)
		{
			System.out.println("Heads");
		}else
		{
			System.out.println("Tails");
		}
	}

2. 
	public static boolean arePermutations(int[] array1, int[] array2)
	{
		int length = array1.length;
		int check;

		for(int i = 0; i < array1.length; i++)
		{
			for(int j = 0; j < array2.length; j++)
			{
				if(array1[i] == array2[j])
				{
					check++;
					break;
				}
			}
		}

		if(check == length)
		{
			return true;
		}else
		{
			return false;
		}
	}

3. Four sequences

Activity 4:

No questions

Activity 5:

No questions

Activity 6:

1. 5/6

2. No, as the last three cards dealt from the deck can either be a pair of elevens or no pair at all. There is a probablity that the last three cards dealt can be the three face cards.

3. No, as the deck is randomly shuffled and the top card of the deck is taken to replace the pair. Having more than one play does allow the player the chance to obtain more cards on the board, making more pairs and depleting the deck. 

Activity 7: Mr. M: 15/15

1. size of the board, card rank (such as ace, two, three, etc.), card suit, card value (1, 2, 3, etc.)

2. a. create game. deal nine cards to the visible board for player
   b. Looks for a set of two cards that sum to eleven
   c. Looks for a set of face cards, jack, queen, king
   d. after a pair is made, deal cards from deck. Check to see if a pair can be made. If not, then the game is lost
   e. repeat steps b-d until there are no cards left in the deck
   f. game is won

3. Yes, it does. //Mr. M: What about user input?

4. a. dealMyCards is called in newGame() method and in the constructor when a new board is created.

   b. isLegal(), anotherPlayIsPossible()

   c. 0, 1, 4, 6, 7

   d. for(int i = 0; i < cIndexes.size(); i++)
   	  {
   	  	 System.out.println(board.cards[i].toString());
   	  }

   e. isLegal(), this is to check if the two cards selected, unless it is a triple face card, will have a sum of eleven and that cards need to be dealt from the deck.

Activity 8:

1. These three games, Tens, Elevens, and Thirteens, have the player make pairs that sum to the name of the game. All games use the same functions, such as isLegal(), anotherPLayIsPossible(), dealCards(), and the Board() constructor. However, some functions are going to implement different methods. For example, isLegal() is going to check that the pair equal to the sum of the game. The only different function is the function containsJQK(), which is only for the game Elevens. 

2. The subclass, ElevensBoard, passes these values to the parent class, Board, by calling the constructor of the parent class and passing the values through the constructor to then set the variables in the parent class. 

3. Yes, the abstract Board class can be implemented by all three games, as all three games use same methods, such as isLegal(),just checks to make sure the pair can be made and anotherPlayIsPossible(), which checks for another pair on the board, though the methods need to be rewritten to accomodate the rules of the game. While the ElevensBoard has another function, containsJQK(), it is only accessed by this class.

Activity 9:

1. The size of the board is stored in the subclass and is passed into the superclass. This allows the size() method to not be abstract, as it still prints out a board of nine cards.

2. The methods for dealing and removing the cards will behave the same in both games. Because of this, the methods do not need to be declared as abstract.

3. This alternate design could work. The methods, isLegal() and anotherPlayIsPossible(), will still be called polymorphically. However, all other non-abstract methods in the Board() class will need to be defined seperately in both classes. 

Activity 10:

No questions
<<<<<<< HEAD

Activity 11:

1. 

2. 

3. 
=======
>>>>>>> 4ae624ac9b4407e37c6a3d414130e36c52d8f1a9
